# ELF x86 - Use After Free - basic
## 1. Source code
```c
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
 
#define BUFLEN 64
 
struct Dog {
    char name[12];
    void (*bark)();
    void (*bringBackTheFlag)();
    void (*death)(struct Dog*);
};
 
struct DogHouse{
    char address[16];
    char name[8];
};
 
int eraseNl(char* line){
    for(;*line != '\n'; line++);
    *line = 0;
    return 0;
}
 
void bark(){
    int i;
    for(i = 3; i > 0; i--){
        puts("UAF!!!");
        sleep(1);
    }
}
 
void bringBackTheFlag(){
    char flag[32];
    FILE* flagFile = fopen(".passwd","r");
    if(flagFile == NULL)
    {
        puts("fopen error");
        exit(1);
    }
    fread(flag, 1, 32, flagFile);
    flag[20] = 0;
    fclose(flagFile);
    puts(flag);
}
 
void death(struct Dog* dog){
    printf("%s run under a car... %s 0-1 car\n", dog->name, dog->name);
    free(dog);
}
 
struct Dog* newDog(char* name){
    printf("You buy a new dog. %s is a good name for him\n", name);
    struct Dog* dog = malloc(sizeof(struct Dog));
    strncpy(dog->name, name, 12);
    dog->bark = bark;
    dog->bringBackTheFlag = bringBackTheFlag;
    dog->death = death;
    return dog;
}
 
void attachDog(struct DogHouse* dogHouse, struct Dog* dog){
    printf("%s lives in %s.\n", dog->name, dogHouse->address);
}
 
void destruct(struct DogHouse* dogHouse){
    if(dogHouse){
        puts("You break the dog house.");
        free(dogHouse);
    }
    else
        puts("You do not have a dog house.");
}
 
struct DogHouse* newDogHouse(){
    char line[BUFLEN] = {0};
   
    struct DogHouse* dogHouse = malloc(sizeof(struct DogHouse));
   
    puts("Where do you build it?");
    fgets(line, BUFLEN, stdin);
    eraseNl(line);
    strncpy(dogHouse->address, line, 16);
   
    puts("How do you name it?");
    fgets(line, 64, stdin);
    eraseNl(line);
    strncpy(dogHouse->name, line, 8);
   
    puts("You build a new dog house.");
   
    return dogHouse;
}
 
int main(){
    int end = 0;
    char order = -1;
    char nl = -1;
    char line[BUFLEN] = {0};
    struct Dog* dog = NULL;
    struct DogHouse* dogHouse = NULL;
    while(!end){
        puts("1: Buy a dog\n2: Make him bark\n3: Bring me the flag\n4: Watch his death\n5: Build dog house\n6: Give dog house to your dog\n7: Break dog house\n0: Quit");
        order = getc(stdin);
        nl = getc(stdin);
        if(nl != '\n'){
            exit(0);
        }
        fseek(stdin,0,SEEK_END);
        switch(order){
        case '1':
            puts("How do you name him?");
            fgets(line, BUFLEN, stdin);
            eraseNl(line);
            dog = newDog(line);
            break;
        case '2':
            if(!dog){
                puts("You do not have a dog.");
                break;
            }
            dog->bark();
            break;
        case '3':
            if(!dog){
                puts("You do not have a dog.");
                break;
            }
            printf("Bring me the flag %s!!!\n", dog->name);
            sleep(2);
            printf("%s prefers to bark...\n", dog->name);
            dog->bark();
            break;
        case '4':
            if(!dog){
                puts("You do not have a dog.");
                break;
            }
            dog->death(dog);
            break;
        case '5':
            dogHouse = newDogHouse();
            break;
        case '6':
            if(!dog){
                puts("You do not have a dog.");
                break;
            }
            if(!dogHouse){
                puts("You do not have a dog house.");
                break;
            }
            attachDog(dogHouse, dog);
            break;
        case '7':
            if(!dogHouse){
                puts("You do not have a dog house.");
                break;
            }
            destruct(dogHouse);
            break;
        case '0':
        default:
            end = 1;
        }
    }
    return 0;
}
```

## 2. Solution

cách tiếp cận: bản thân tựa đề cũng đã cho hint cho ta được vuln mà ta cần tìm hiểu ở đây là gì.

UAF có nghĩa là khi ta dùng malloc trong 1 chương trình, thì chương trình sẽ allocate 1 vùng nhớ cho ta. khi ta dùng xong vùng nhớ đó và không dùng nữa thì lúc này chúng ta sẽ dùng hàm `free` 

tại đây free không phải là xóa nội dung vùng nhớ mà nó chỉ đơn giản là unlink con trỏ tại vùng nhớ đó, còn nội dung vùng nhớ vẫn giữ nguyên

đây là 1 cấu trúc của malloc chunk khi được allocate

```c
struct malloc_chunk {
  INTERNAL_SIZE_T      mchunk_prev_size;  /* Size of previous chunk (if free).  */
  INTERNAL_SIZE_T      mchunk_size;       /* Size in bytes, including overhead. */
  struct malloc_chunk* fd;                /* double links -- used only if free. */
  struct malloc_chunk* bk;
  /* Only used for large blocks: pointer to next larger size.  */
  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */
  struct malloc_chunk* bk_nextsize;
};
```

bây giờ ta sẽ tóm gọn lại nội dung của source.

source gồm có 7 lựa chọn chính đó là 
```
1/	Mua 1 con dog
2/	làm nó bark
3/	flag
4/	giết dog
5/	xây nhà
6/	đặt tên nhà
7/	phá nhà
```
ta có cấu trúc của dog là (mỗi dòng là 4 bytes)
```
+------+
|......|
|......|	<=== name[12]
|......|
+------+
|......|	<=== bark
+------+
|......|	<=== flag
+------+
|......|	<=== death
+------+
```
và cấu trúc của căn nhà
```
+------+
|......|
|......|	<=== address[16]
|......|
|......|
+------+
|......|
|......|	<=== name[8]
+------+
```

lúc này, ta sẽ đi qua 1 vài options cần thiết cho exploit

>+	Option 1: đây là nơi ta sẽ allocate heap
>+	Option 2 và 3: đây sẽ là nơi mà ta gọi hàm `bringBackTheFlag`

```c
case '2':
	...	
	dog->bark();
	break;
case '3':
	...
	printf("Bring me the flag %s!!!\n", dog->name);
	sleep(2);
	printf("%s prefers to bark...\n", dog->name);
	dog->bark();
	break;
```

>+ option 4: đây là hàm free
>+ option 5: ép heap của nhà vào heap của dog

```
+------+		+------+
|......|		|......|
|......|		|......|
|......|		|......|
+------+                ~~~~~~~~    <== chỗ này chỉ để fill chỗ trống cho nó giống cấu trúc
|......|		|......|
+------+		+------+
|......|		|......|
+------+		|......|
|......|		+------+
+------+		
```

bây giờ tiến hành exploit

-	đầu tiên là allocate dog

<img src="https://i.imgur.com/xvPO0kT.png">

-	test thử sau khi free thì option 2, 3 vẫn dùng được

<img src="https://i.imgur.com/74j5z98.png">

ở đây ta thấy lúc gọi option 3 thì nó có gọi tên của dog, nhưng vì đã bị unlink khỏi heap nên nó sẽ không có giá trị (thực chất tên cobalt vẫn còn đó)

sơ bộ như vậy ta đã hiểu được UAF hoạt động như thế nào, bây giờ sau khi ta free dog xong thì ta sẽ allocate nó 1 house mới, và với cách đó ta sẽ điền 4 bytes địa chỉ vào hàm `bark` để có thể lấy được flag

payload 

`'1\n'+'cobalt\n' + '4\n5\n' + [12 bytes junk] + [4 bytes địa chỉ flag] + '\n' + 'junk\n' + '2\n' `

<img src="https://i.imgur.com/zA0No5k.png">

