# ELF x86 - Stack buffer overflow basic 1
## 1. Source code

```c
#include <unistd.h>
#include <sys/types.h>
#include <stdlib.h>
#include <stdio.h>
 
int main()
{
 
  int var;
  int check = 0x04030201;
  char buf[40];
 
  fgets(buf,45,stdin);
 
  printf("\n[buf]: %s\n", buf);
  printf("[check] %p\n", check);
 
  if ((check != 0x04030201) && (check != 0xdeadbeef))
    printf ("\nYou are on the right way!\n");
 
  if (check == 0xdeadbeef)
   {
     printf("Yeah dude! You win!\nOpening your shell...\n");
     setreuid(geteuid(), geteuid());
     system("/bin/bash");
     printf("Shell closed! Bye.\n");
   }
   return 0;
}
```

## 2. Solution

- Việc đầu tiên mình làm đó chính là đọc tiêu đề vì đôi khi tiêu đề chính là nơi giúp ta giải quyết được kha khá bài toán
- kể đến chính là tìm hiểu về stack của source
- Ta thấy đầu tiên chương trình tạo 3 biến: var, check, buf[40]. Lúc này stack của ta có hình dạng như sau

|	40bytes		|	
|---------------|
|	0x04030201	|
|	var 		|	

nếu ta tìm hiểu rõ về stack thì ta sẽ biết stack thì ta sẽ biết rằng stack sẽ grow theo chiều từ high address - low address
còn buffer grow ngược lại tức là từ low addr - high addr

<img src="https://i.imgur.com/EjcWlKO.png">

vậy giờ ta đã hiểu được cách mà buffer overflow sang biến check

### 3. Exploitation

- login vào server

<img src="https://i.imgur.com/HTvX8VO.png">

- exec thử bin

<img src="https://i.imgur.com/YiLmTek.png">

- như đã giải thích ở trên thì việc của chúng ta bây giờ chỉ cần tìm được offset của biến buf để overflow sang biến check
- giờ dùng gdb để disassemble 
- do đây là challenge đầu tiên và dễ nên offset của buf = 40 (lúc khai báo trong source), vì thông thường hệ máy sẽ 
reserved 1 vài bytes offset của biến
- giờ nhập thử 41 bytes 

<img src="https://i.imgur.com/COsqhzf.png">

- ta để ý thấy 0x61 = "a", vậy bây giờ việc của ta là overflow biến check
- chú ý vì ở đây là hệ máy intel nên ta cần phải đổi giá trị 0xdeadbeef thành little endian
- `\xef\xbe\xad\xde`
- vậy bây giờ thì payload của ta sẽ thành

`40 bytes junk + \xef\xbe\xad\xde`

<img src="https://i.imgur.com/OWg0FY0.png">

như ta thấy vì chương trình nó chỉ thực hiện hàm `system("/bin/bash")`, hàm này để gain được root access
nhưng ta lại không có dừng stdout của chương trình nên nó chỉ gain root cho ta rồi sau đó kết thúc process

tại đây ta có 2 cách để dừng stdout của chương trình

- cách 1: `cat < ([command]) - | ./ch13`
- cách 2: `( [command]; cat ) | ./ch13`

tại đây ta sẽ dùng cách 2 

<img src="https://i.imgur.com/8uzbhPy.png">

như vậy là ta đã gain được shell của challenge. việc cuối cùng là `cat` flag .

<img src="https://i.imgur.com/zQOw7cZ.png">
