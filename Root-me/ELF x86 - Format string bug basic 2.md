# ELF x86 - Format string bug basic 2
## 1. Source code
```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
 
int main( int argc, char ** argv )
 
{
 
        int var;
        int check  = 0x04030201;
 
        char fmt[128];
 
        if (argc <2)
                exit(0);
 
        memset( fmt, 0, sizeof(fmt) );
 
        printf( "check at 0x%x\n", &check );
        printf( "argv[1] = [%s]\n", argv[1] );
 
        snprintf( fmt, sizeof(fmt), argv[1] );
 
        if ((check != 0x04030201) && (check != 0xdeadbeef))    
                printf ("\nYou are on the right way !\n");
 
        printf( "fmt=[%s]\n", fmt );
        printf( "check=0x%x\n", check );
 
        if (check==0xdeadbeef)
        {
                printf("Yeah dude ! You win !\n");
                setreuid(geteuid(), geteuid());
                system("/bin/bash");
        }
}
```
## 2. Solution

tại đây chúng ta thấy 

```c
 snprintf( fmt, sizeof(fmt), argv[1] );
```

là nơi mà xảy ra fmt của binary. Khi ta đã xác định được là lỗi fmt thì lúc này ta có thể control được fmt của chương trình. Trong ngữ cảnh của đề thì đề yêu cầu ta control fmt để thay đổi giá trị của biến var thằng `0xdeadbeef`

Để control được biến var ta cần phải hiểu được các cách dùng fmt như thế nào

<img src="https://i.imgur.com/qv5oM0w.png">

thông qua hình trên thì ta thấy có `%n` là format chính để ta dùng để thay đổi giá trị của biến var

- Bây giờ ta sẽ leak memory của chương trình thông qua việc dùng nhiều kí tự `%08x.`

<img src="https://i.imgur.com/VO9epyF.png">

- Giờ ta sẽ đi tìm vị trí của fmt trên stack để ta control được nó

<img src="https://i.imgur.com/FIyDqRU.png">

như ta thấy thì khi ta tìm được vị trí của fmt thì trước nó chính là vị trí của biến var, vậy bây giờ việc kế đến chính là tìm địa chỉ của biến var (nhưng đề đã tìm giúp chúng ta rồi!!!) rồi mình padding với `1 dãy khoảng trắng = %nx (n là padding)`

như vậy vị trí của fmt là vị trí thứ 9 trên memory ta vừa leak được, kết hợp với index `$` để control fmt (nhớ kết hợp với \$ để escape vì `$` trong linux nó dùng để nhập bash command)

<img src="https://i.imgur.com/TQsg5z8.png">

bây giờ thì để `var = 0xdeadbeef'` thì ta phải dùng `%n` để sửa đổi byte trên memory

vì binary của chúng ta dùng arch intel nên nó sẽ theo dạng little endian, nên ta sẽ phải overwrite từ beef trước

test thử tác dụng của `%n`

<img src="https://i.imgur.com/XoemOmM.png">

như ta thấy bên trên thì giá trị của var lúc này bằng `0x4` tại sao lại như vậy? vì ta truyền vào 4 bytes (địa chỉ của biến var) nên `%n` đếm được 4bytes có trong memory

bây giờ ta sẽ đổi `0xbeef` thành hệ decimal, vì sao? như ta thấy %n chỉ đếm số bytes rồi overwrite nó trên memory của chương trình nên việc đổi thành decimal là cần thiết

<img src="https://i.imgur.com/gTdJKIO.png">

vậy bây giờ lúc này ta đã có được giá trị decimal của `0xbeef` bây giờ việc của ta là cho nó vào payload của mình


-cho vào payload

<img src="https://i.imgur.com/SMrlJHH.png">

ta thấy được rằng khi ta thêm vào 1 format specifier thì địa chỉ của var bị thụt mất 16bytes, vì mỗi format specifier chiếm 16bytes trong memory. Vậy bây giờ ta chỉ cần sửa lại địa chỉ của trong payload là được (trừ đi `0x10`)

<img src="https://i.imgur.com/MpEaJbi.png">

như ta thấy ta đã overwrite được giá trị của biến var nhưng khoan đã, tại sao nó lại không phải là `0xbeef` mà là `0xbef3`??? mình thử trừ `0xbef3` cho `0x4`, thì nó lại trở thành `0xbeef`, tại sao lại như vậy? hãy để ý đến 4 bytes của địa chỉ mà ta cho vào payload bên trên chính vì nó đã chiếm mất 4 bytes padding của chúng ta, nên bây giờ ta sẽ trừ bớt đi 4 bytes trong padding là ta ra được `0xbeef`

-thực hiện

<img src="https://i.imgur.com/bVjOsRk.png">

Rồi, bây giờ làm sao chúng ta thêm được `0xdead` vào trước nó? như ta biết thì địa chỉ của var sao khi thêm 1 format specifier là `0xbffffa08`.

<img src="https://i.imgur.com/aGVSWt8.png">

như hình trên ta có thể thấy được mỗi byte trên stack đều có mỗi địa chỉ riêng của nó. Vì ta đã điều chỉnh 2 bytes của biến var (là vị trí `0x08` và `0x09`) nên bây giờ ta chỉ cần thêm 4 bytes tại địa chỉ kế tiếp của nó là ta điều chỉnh được nó thành `0xdead = 57005 (hệ 10)`

-thực hiện

<img src="https://i.imgur.com/zTj1l0I.png">

như đã nói, vì ta chỉ điều chỉnh được 2 bytes mỗi lần nên ta buộc phải thêm 4 bytes của địa chỉ biến `var` để có thể điều chỉnh tiếp tục. Khi ta thêm 4 bytes thì lúc này padding của 2 bytes trước sẽ phải trừ tiếp thêm 4 bytes nữa và nó thành `%48871x`

kế đến chính là `%10\$n`, vì khi ta thêm 4 bytes nữa lúc này ta buộc phải thêm 1 format specifier (điều này lại dẫn đến địa chỉ của biến var bị trừ bớt đi 16 bytes lúc này nó trở thành `0xbffff9f8`) và vì ta đã có được padding trước đó là 48871 bytes, còn `dead` thì có 57005, ta chỉ việc lấy 57005 - 48871 = 8126 là biến `0xdead` sẽ được ghi vào biến var đó

<img src="https://i.imgur.com/cK8LFP5.png">
